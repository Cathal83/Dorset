/*! 12.2.13 */
!window.XMLHttpRequest || window.FileAPI && FileAPI.shouldLoad || (window.XMLHttpRequest.prototype.setRequestHeader = function (a) { return function (b, c) { if ("__setXHR_" === b) { var d = c(this); d instanceof Function && d(this) } else a.apply(this, arguments) } }(window.XMLHttpRequest.prototype.setRequestHeader)); var ngFileUpload = angular.module("ngFileUpload", []); ngFileUpload.version = "12.2.13", ngFileUpload.service("UploadBase", ["$http", "$q", "$timeout", function (a, b, c) { function d(d) { function e(a) { j.notify && j.notify(a), k.progressFunc && c(function () { k.progressFunc(a) }) } function h(a) { return null != d._start && g ? { loaded: a.loaded + d._start, total: d._file && d._file.size || a.total, type: a.type, config: d, lengthComputable: !0, target: a.target } : a } function i() { a(d).then(function (a) { if (g && d._chunkSize && !d._finished && d._file) { var b = d._file && d._file.size || 0; e({ loaded: Math.min(d._end, b), total: b, config: d, type: "progress" }), f.upload(d, !0) } else d._finished && delete d._finished, j.resolve(a) }, function (a) { j.reject(a) }, function (a) { j.notify(a) }) } d.method = d.method || "POST", d.headers = d.headers || {}; var j = d._deferred = d._deferred || b.defer(), k = j.promise; return d.disableProgress || (d.headers.__setXHR_ = function () { return function (a) { a && a.upload && a.upload.addEventListener && (d.__XHR = a, d.xhrFn && d.xhrFn(a), a.upload.addEventListener("progress", function (a) { a.config = d, e(h(a)) }, !1), a.upload.addEventListener("load", function (a) { a.lengthComputable && (a.config = d, e(h(a))) }, !1)) } }), g ? d._chunkSize && d._end && !d._finished ? (d._start = d._end, d._end += d._chunkSize, i()) : d.resumeSizeUrl ? a.get(d.resumeSizeUrl).then(function (a) { d._start = d.resumeSizeResponseReader ? d.resumeSizeResponseReader(a.data) : parseInt((null == a.data.size ? a.data : a.data.size).toString()), d._chunkSize && (d._end = d._start + d._chunkSize), i() }, function (a) { throw a }) : d.resumeSize ? d.resumeSize().then(function (a) { d._start = a, d._chunkSize && (d._end = d._start + d._chunkSize), i() }, function (a) { throw a }) : (d._chunkSize && (d._start = 0, d._end = d._start + d._chunkSize), i()) : i(), k.success = function (a) { return k.then(function (b) { a(b.data, b.status, b.headers, d) }), k }, k.error = function (a) { return k.then(null, function (b) { a(b.data, b.status, b.headers, d) }), k }, k.progress = function (a) { return k.progressFunc = a, k.then(null, null, function (b) { a(b) }), k }, k.abort = k.pause = function () { return d.__XHR && c(function () { d.__XHR.abort() }), k }, k.xhr = function (a) { return d.xhrFn = function (b) { return function () { b && b.apply(k, arguments), a.apply(k, arguments) } }(d.xhrFn), k }, f.promisesCount++ , k["finally"] && k["finally"] instanceof Function && k["finally"](function () { f.promisesCount-- }), k } function e(a) { var b = {}; for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]); return b } var f = this; f.promisesCount = 0, this.isResumeSupported = function () { return window.Blob && window.Blob.prototype.slice }; var g = this.isResumeSupported(); this.isUploadInProgress = function () { return f.promisesCount > 0 }, this.rename = function (a, b) { return a.ngfName = b, a }, this.jsonBlob = function (a) { null == a || angular.isString(a) || (a = JSON.stringify(a)); var b = new window.Blob([a], { type: "application/json" }); return b._ngfBlob = !0, b }, this.json = function (a) { return angular.toJson(a) }, this.isFile = function (a) { return null != a && (a instanceof window.Blob || a.flashId && a.name && a.size) }, this.upload = function (a, b) { function c(b, c) { if (b._ngfBlob) return b; if (a._file = a._file || b, null != a._start && g) { a._end && a._end >= b.size && (a._finished = !0, a._end = b.size); var d = b.slice(a._start, a._end || b.size); return d.name = b.name, d.ngfName = b.ngfName, a._chunkSize && (c.append("_chunkSize", a._chunkSize), c.append("_currentChunkSize", a._end - a._start), c.append("_chunkNumber", Math.floor(a._start / a._chunkSize)), c.append("_totalSize", a._file.size)), d } return b } function h(b, d, e) { if (void 0 !== d) if (angular.isDate(d) && (d = d.toISOString()), angular.isString(d)) b.append(e, d); else if (f.isFile(d)) { var g = c(d, b), i = e.split(","); i[1] && (g.ngfName = i[1].replace(/^\s+|\s+$/g, ""), e = i[0]), a._fileKey = a._fileKey || e, b.append(e, g, g.ngfName || g.name) } else if (angular.isObject(d)) { if (d.$$ngfCircularDetection) throw "ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: " + e; d.$$ngfCircularDetection = !0; try { for (var j in d) if (d.hasOwnProperty(j) && "$$ngfCircularDetection" !== j) { var k = null == a.objectKey ? "[i]" : a.objectKey; d.length && parseInt(j) > -1 && (k = null == a.arrayKey ? k : a.arrayKey), h(b, d[j], e + k.replace(/[ik]/g, j)) } } finally { delete d.$$ngfCircularDetection } } else b.append(e, d) } function i() { a._chunkSize = f.translateScalars(a.resumeChunkSize), a._chunkSize = a._chunkSize ? parseInt(a._chunkSize.toString()) : null, a.headers = a.headers || {}, a.headers["Content-Type"] = void 0, a.transformRequest = a.transformRequest ? angular.isArray(a.transformRequest) ? a.transformRequest : [a.transformRequest] : [], a.transformRequest.push(function (b) { var c, d = new window.FormData; b = b || a.fields || {}, a.file && (b.file = a.file); for (c in b) if (b.hasOwnProperty(c)) { var e = b[c]; a.formDataAppender ? a.formDataAppender(d, c, e) : h(d, e, c) } return d }) } return b || (a = e(a)), a._isDigested || (a._isDigested = !0, i()), d(a) }, this.http = function (b) { return b = e(b), b.transformRequest = b.transformRequest || function (b) { return window.ArrayBuffer && b instanceof window.ArrayBuffer || b instanceof window.Blob ? b : a.defaults.transformRequest[0].apply(this, arguments) }, b._chunkSize = f.translateScalars(b.resumeChunkSize), b._chunkSize = b._chunkSize ? parseInt(b._chunkSize.toString()) : null, d(b) }, this.translateScalars = function (a) { if (angular.isString(a)) { if (a.search(/kb/i) === a.length - 2) return parseFloat(1024 * a.substring(0, a.length - 2)); if (a.search(/mb/i) === a.length - 2) return parseFloat(1048576 * a.substring(0, a.length - 2)); if (a.search(/gb/i) === a.length - 2) return parseFloat(1073741824 * a.substring(0, a.length - 2)); if (a.search(/b/i) === a.length - 1) return parseFloat(a.substring(0, a.length - 1)); if (a.search(/s/i) === a.length - 1) return parseFloat(a.substring(0, a.length - 1)); if (a.search(/m/i) === a.length - 1) return parseFloat(60 * a.substring(0, a.length - 1)); if (a.search(/h/i) === a.length - 1) return parseFloat(3600 * a.substring(0, a.length - 1)) } return a }, this.urlToBlob = function (c) { var d = b.defer(); return a({ url: c, method: "get", responseType: "arraybuffer" }).then(function (a) { var b = new Uint8Array(a.data), e = a.headers("content-type") || "image/WebP", f = new window.Blob([b], { type: e }), g = c.match(/.*\/(.+?)(\?.*)?$/); g.length > 1 && (f.name = g[1]), d.resolve(f) }, function (a) { d.reject(a) }), d.promise }, this.setDefaults = function (a) { this.defaults = a || {} }, this.defaults = {}, this.version = ngFileUpload.version }]), ngFileUpload.service("Upload", ["$parse", "$timeout", "$compile", "$q", "UploadExif", function (a, b, c, d, e) {
  function f(a, b, c) { var e = [i.emptyPromise()]; return angular.forEach(a, function (d, f) { 0 === d.type.indexOf("image/jpeg") && i.attrGetter("ngfFixOrientation", b, c, { $file: d }) && e.push(i.happyPromise(i.applyExifRotation(d), d).then(function (b) { a.splice(f, 1, b) })) }), d.all(e) } function g(a, b, c, e) { var f = i.attrGetter("ngfResize", b, c); if (!f || !i.isResizeSupported() || !a.length) return i.emptyPromise(); if (f instanceof Function) { var g = d.defer(); return f(a).then(function (d) { h(d, a, b, c, e).then(function (a) { g.resolve(a) }, function (a) { g.reject(a) }) }, function (a) { g.reject(a) }) } return h(f, a, b, c, e) } function h(a, b, c, e, f) { function g(d, g) { if (0 === d.type.indexOf("image")) { if (a.pattern && !i.validatePattern(d, a.pattern)) return; a.resizeIf = function (a, b) { return i.attrGetter("ngfResizeIf", c, e, { $width: a, $height: b, $file: d }) }; var j = i.resize(d, a); h.push(j), j.then(function (a) { b.splice(g, 1, a) }, function (a) { d.$error = "resize", (d.$errorMessages = d.$errorMessages || {}).resize = !0, d.$errorParam = (a ? (a.message ? a.message : a) + ": " : "") + (d && d.name), f.$ngfValidations.push({ name: "resize", valid: !1 }), i.applyModelValidation(f, b) }) } } for (var h = [i.emptyPromise()], j = 0; j < b.length; j++)g(b[j], j); return d.all(h) } var i = e; return i.getAttrWithDefaults = function (a, b) { if (null != a[b]) return a[b]; var c = i.defaults[b]; return null == c ? c : angular.isString(c) ? c : JSON.stringify(c) }, i.attrGetter = function (b, c, d, e) { var f = this.getAttrWithDefaults(c, b); if (!d) return f; try { return e ? a(f)(d, e) : a(f)(d) } catch (g) { if (b.search(/min|max|pattern/i)) return f; throw g } }, i.shouldUpdateOn = function (a, b, c) { var d = i.attrGetter("ngfModelOptions", b, c); return d && d.updateOn ? d.updateOn.split(" ").indexOf(a) > -1 : !0 }, i.emptyPromise = function () { var a = d.defer(), c = arguments; return b(function () { a.resolve.apply(a, c) }), a.promise }, i.rejectPromise = function () { var a = d.defer(), c = arguments; return b(function () { a.reject.apply(a, c) }), a.promise }, i.happyPromise = function (a, c) { var e = d.defer(); return a.then(function (a) { e.resolve(a) }, function (a) { b(function () { throw a }), e.resolve(c) }), e.promise }, i.updateModel = function (c, d, e, h, j, k, l) {
    function m(f, g, j, l, m) { d.$$ngfPrevValidFiles = f, d.$$ngfPrevInvalidFiles = g; var n = f && f.length ? f[0] : null, o = g && g.length ? g[0] : null; c && (i.applyModelValidation(c, f), c.$setViewValue(m ? n : f)), h && a(h)(e, { $files: f, $file: n, $newFiles: j, $duplicateFiles: l, $invalidFiles: g, $invalidFile: o, $event: k }); var p = i.attrGetter("ngfModelInvalid", d); p && b(function () { a(p).assign(e, m ? o : g) }), b(function () { }) } function n() { function a(a, b) { return a.name === b.name && (a.$ngfOrigSize || a.size) === (b.$ngfOrigSize || b.size) && a.type === b.type } function b(b) { var c; for (c = 0; c < r.length; c++)if (a(b, r[c])) return !0; for (c = 0; c < s.length; c++)if (a(b, s[c])) return !0; return !1 } if (j) { q = [], t = []; for (var c = 0; c < j.length; c++)b(j[c]) ? t.push(j[c]) : q.push(j[c]) } } function o(a) { return angular.isArray(a) ? a : [a] } function p() { function a() { b(function () { m(w ? r.concat(v) : v, w ? s.concat(u) : u, j, t, x) }, z && z.debounce ? z.debounce.change || z.debounce : 0) } var f = y ? q : v; g(f, d, e, c).then(function () { y ? i.validate(q, w ? r.length : 0, c, d, e).then(function (b) { v = b.validsFiles, u = b.invalidsFiles, a() }) : a() }, function () { for (var b = 0; b < f.length; b++) { var c = f[b]; if ("resize" === c.$error) { var d = v.indexOf(c); d > -1 && (v.splice(d, 1), u.push(c)), a() } } }) } var q, r, s, t = [], u = [], v = []; r = d.$$ngfPrevValidFiles || [], s = d.$$ngfPrevInvalidFiles || [], c && c.$modelValue && (r = o(c.$modelValue)); var w = i.attrGetter("ngfKeep", d, e); q = (j || []).slice(0), ("distinct" === w || i.attrGetter("ngfKeepDistinct", d, e) === !0) && n(d, e); var x = !w && !i.attrGetter("ngfMultiple", d, e) && !i.attrGetter("multiple", d); if (!w || q.length) {
      i.attrGetter("ngfBeforeModelChange", d, e, {
        $files: j, $file: j && j.length ? j[0] :
          v(a) && b.stopPropagation(), u=g(function () { t && c.removeClass(t), t = null, s("ngfDrag", a, { $isDragging: !1, $event: b }) }, w || 100))
    }, !1), c[0].addEventListener("drop", function (b) { !l() && i.shouldUpdateOn("drop", d, a) && (b.preventDefault(), v(a) && b.stopPropagation(), t && c.removeClass(t), t = null, m(b.dataTransfer, b, "dropUrl")) }, !1), c[0].addEventListener("paste", function (b) { navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && s("ngfEnableFirefoxPaste", a) && b.preventDefault(), !l() && i.shouldUpdateOn("paste", d, a) && m(b.clipboardData || b.originalEvent.clipboardData, b, "pasteUrl") }, !1), navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && s("ngfEnableFirefoxPaste", a) && (c.attr("contenteditable", !0), c.on("keypress", function (a) { a.metaKey || a.ctrlKey || a.preventDefault() }))}function b() { var a = document.createElement("div"); return "draggable" in a && "ondrop" in a && !/Edge\/12./i.test(navigator.userAgent) } ngFileUpload.directive("ngfDrop", ["$parse", "$timeout", "$window", "Upload", "$http", "$q", function (b, c, d, e, f, g) { return { restrict: "AEC", require: "?ngModel", link: function (h, i, j, k) { a(h, i, j, k, b, c, d, e, f, g) } } }]), ngFileUpload.directive("ngfNoFileDrop", function () { return function (a, c) { b() && c.css("display", "none") } }), ngFileUpload.directive("ngfDropAvailable", ["$parse", "$timeout", "Upload", function (a, c, d) { return function (e, f, g) { if (b()) { var h = a(d.attrGetter("ngfDropAvailable", g)); c(function () { h(e), h.assign && h.assign(e, !0) }) } } }])}(), ngFileUpload.service("UploadExif", ["UploadResize", "$q", function (a, b) { function c(a, b, c, d) { switch (b) { case 2: return a.transform(-1, 0, 0, 1, c, 0); case 3: return a.transform(-1, 0, 0, -1, c, d); case 4: return a.transform(1, 0, 0, -1, 0, d); case 5: return a.transform(0, 1, 1, 0, 0, 0); case 6: return a.transform(0, 1, -1, 0, d, 0); case 7: return a.transform(0, -1, -1, 0, d, c); case 8: return a.transform(0, -1, 1, 0, 0, c) } } function d(a) { for (var b = "", c = new Uint8Array(a), d = c.byteLength, e = 0; d > e; e++)b += String.fromCharCode(c[e]); return window.btoa(b) } var e = a; return e.isExifSupported = function () { return window.FileReader && (new FileReader).readAsArrayBuffer && e.isResizeSupported() }, e.readOrientation = function (a) { var c = b.defer(), d = new FileReader, e = a.slice ? a.slice(0, 65536) : a; return d.readAsArrayBuffer(e), d.onerror = function (a) { return c.reject(a) }, d.onload = function (a) { var b = { orientation: 1 }, d = new DataView(this.result); if (65496 !== d.getUint16(0, !1)) return c.resolve(b); for (var e = d.byteLength, f = 2; e > f;) { var g = d.getUint16(f, !1); if (f += 2, 65505 === g) { if (1165519206 !== d.getUint32(f += 2, !1)) return c.resolve(b); var h = 18761 === d.getUint16(f += 6, !1); f += d.getUint32(f + 4, h); var i = d.getUint16(f, h); f += 2; for (var j = 0; i > j; j++)if (274 === d.getUint16(f + 12 * j, h)) { var k = d.getUint16(f + 12 * j + 8, h); return k >= 2 && 8 >= k && (d.setUint16(f + 12 * j + 8, 1, h), b.fixedArrayBuffer = a.target.result), b.orientation = k, c.resolve(b) } } else { if (65280 !== (65280 & g)) break; f += d.getUint16(f, !1) } } return c.resolve(b) }, c.promise }, e.applyExifRotation = function (a) { if (0 !== a.type.indexOf("image/jpeg")) return e.emptyPromise(a); var f = b.defer(); return e.readOrientation(a).then(function (b) { return b.orientation < 2 || b.orientation > 8 ? f.resolve(a) : void e.dataUrl(a, !0).then(function (g) { var h = document.createElement("canvas"), i = document.createElement("img"); i.onload = function () { try { h.width = b.orientation > 4 ? i.height : i.width, h.height = b.orientation > 4 ? i.width : i.height; var g = h.getContext("2d"); c(g, b.orientation, i.width, i.height), g.drawImage(i, 0, 0); var j = h.toDataURL(a.type || "image/WebP", .934); j = e.restoreExif(d(b.fixedArrayBuffer), j); var k = e.dataUrltoBlob(j, a.name); f.resolve(k) } catch (l) { return f.reject(l) } }, i.onerror = function () { f.reject() }, i.src = g }, function (a) { f.reject(a) }) }, function (a) { f.reject(a) }), f.promise }, e.restoreExif = function (a, b) { var c = {}; return c.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", c.encode64 = function (a) { var b, c, d, e, f, g = "", h = "", i = "", j = 0; do b = a[j++], c = a[j++], h = a[j++], d = b >> 2, e = (3 & b) << 4 | c >> 4, f = (15 & c) << 2 | h >> 6, i = 63 & h, isNaN(c) ? f = i = 64 : isNaN(h) && (i = 64), g = g + this.KEY_STR.charAt(d) + this.KEY_STR.charAt(e) + this.KEY_STR.charAt(f) + this.KEY_STR.charAt(i), b = c = h = "", d = e = f = i = ""; while (j < a.length); return g }, c.restore = function (a, b) { a.match("data:image/jpeg;base64,") && (a = a.replace("data:image/jpeg;base64,", "")); var c = this.decode64(a), d = this.slice2Segments(c), e = this.exifManipulation(b, d); return "data:image/jpeg;base64," + this.encode64(e) }, c.exifManipulation = function (a, b) { var c = this.getExifArray(b), d = this.insertExif(a, c); return new Uint8Array(d) }, c.getExifArray = function (a) { for (var b, c = 0; c < a.length; c++)if (b = a[c], 255 === b[0] & 225 === b[1]) return b; return [] }, c.insertExif = function (a, b) { var c = a.replace("data:image/jpeg;base64,", ""), d = this.decode64(c), e = d.indexOf(255, 3), f = d.slice(0, e), g = d.slice(e), h = f; return h = h.concat(b), h = h.concat(g) }, c.slice2Segments = function (a) { for (var b = 0, c = []; ;) { if (255 === a[b] & 218 === a[b + 1]) break; if (255 === a[b] & 216 === a[b + 1]) b += 2; else { var d = 256 * a[b + 2] + a[b + 3], e = b + d + 2, f = a.slice(b, e); c.push(f), b = e } if (b > a.length) break } return c }, c.decode64 = function (a) { var b, c, d, e, f, g = "", h = "", i = 0, j = [], k = /[^A-Za-z0-9\+\/\=]/g; k.exec(a) && console.log("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, NaNExpect errors in decoding."), a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); do d = this.KEY_STR.indexOf(a.charAt(i++)), e = this.KEY_STR.indexOf(a.charAt(i++)), f = this.KEY_STR.indexOf(a.charAt(i++)), h = this.KEY_STR.indexOf(a.charAt(i++)), b = d << 2 | e >> 4, c = (15 & e) << 4 | f >> 2, g = (3 & f) << 6 | h, j.push(b), 64 !== f && j.push(c), 64 !== h && j.push(g), b = c = g = "", d = e = f = h = ""; while (i < a.length); return j }, c.restore(a, b) }, e }]);
